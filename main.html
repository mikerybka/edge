<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>16 Lines 15px High Stripes</title>
  <style>
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid black;
      image-rendering: pixelated;
      background: white;
    }
  </style>
</head>
<body>
  <canvas id="stripedCanvas" width="320" height="240"></canvas>
  <script>
    const canvas = document.getElementById('stripedCanvas');
    const ctx = canvas.getContext('2d');
    const stripeHeight = canvas.height / 16; // 15
    const fontSize = stripeHeight / 15 * 13;
    const maxWidth = 300;
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textBaseline = "middle";
    let inputText = "";
    let cursorIndex = 0;
    let blinkState = true;
    let messages = [];
    let scrollOffset = 0;
    // let lines = [
    //     "",
    //     "",
    //     "Hey, how's it going?",
    //     "",
    //     "",
    //     "Not bad, yourself?",
    //     "",
    //     "",
    //     "I'm good, thanks.",
    //     "",
    //     "",
    //     "How's the wife and kids?",
    //     "",
    //     "",
    //     "They're great! Just got back from vacation",
    //     "in the Poconos.",
    //     "",
    // ];

    // function calculateLines(inputText, messages) {
    //     const lines = [];
        
    //     // Calculate input text area
    //     let workingLine = "";
    //     inputText.split(" ").forEach((word, i) => {
    //         const testLine = workingLine + " " + word + " ";
    //         const metrics = ctx.measureText(testLine);
    //         const testWidth = metrics.width;
    //         if (testWidth > maxWidth && i > 0) {
    //             lines.push({text: workingLine.trim(), align: "left"});
    //             workingLine = "";
    //         } else {
    //             workingLine = testLine;
    //         }
    //     });
    //     lines.push({text: workingLine.trim(), align: "left"});
    //     lines.push({text: "", align: "left"});
    //     lines.reverse();
        
    //     // Calculate messages
    //     Array.from(messages.slice(-5)).reverse().forEach(msg => {
    //         const align = msg.from === "me" ? "right" : "left";
    //         const msgLines = [];
    //         workingLine = ""
    //         msg.text.split(" ").forEach((word, i) => {
    //             const testLine = workingLine + " " + word + " ";
    //             const metrics = ctx.measureText(testLine);
    //             const testWidth = metrics.width;
    //             if (testWidth > maxWidth && i > 0) {
    //                 msgLines.push({text: workingLine.trim(), align});
    //                 workingLine = "";
    //             } else {
    //                 workingLine = testLine
    //             }
    //         });
    //         msgLines.reverse().forEach(line => {
    //             lines.push(line);
    //         })
    //         lines.push({text: "", align});
    //         lines.push({text: "", align});
    //     });

    //     if (lines.length < 17) {
    //         for (let i = lines.length; i < 17; i++) {
    //             lines.push({text: "", align: "left"})
    //         }
    //     }

    //     return lines.slice(0, 17).reverse()
    // }

    function calculateLines() {
        // TODO
    }

    function draw() {
        const baseWidth = 160;
        ctx.clearRect(0, 0, width, height);
        const maxInputTextWidth = width * 137/baseWidth;
        const maxMessageTextWidth = width * 150/baseWidth;
        const margin = 1 * width/baseWidth;
        const padding = 3 * width/baseWidth;
        
        // Clear canvas
        const width = canvas.width;
        const height = canvas.height;

        // Draw input box
        const inputLines = calculateLines(maxInputTextWidth, inputText)

        // const lines = calculateLines(inputText, messages);
        // lines.forEach((line, i) => {
        //     const textY = i * stripeHeight;
        //     if (line.align === "right") {
        //         ctx.textAlign = "right";
        //         ctx.fillText(line.text, width-8, textY);
        //     } else {
        //         ctx.textAlign = "left";
        //         ctx.fillText(line.text, 8, textY);
        //     }
        // })

        // Draw messages

        // Draw blinking cursor
        // if (blinkState) {
        //     const inputPadding = 8;

        //     const beforeCursor = inputText.slice(0, cursorIndex);
        //     const cursorX = inputPadding + ctx.measureText(beforeCursor).width;
        //     ctx.beginPath();
        //     ctx.moveTo(cursorX, canvas.height - inputBoxHeight + 6);
        //     ctx.lineTo(cursorX, canvas.height - inputPadding - 6);
        //     ctx.strokeStyle = "#000";
        //     ctx.stroke();
        // }
    }

    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey || e.metaKey) return;

      if (e.key === "ArrowLeft") {
        if (cursorIndex > 0) cursorIndex--;
      } else if (e.key === "ArrowRight") {
        if (cursorIndex < inputText.length) cursorIndex++;
      } else if (e.key === "Backspace") {
        if (cursorIndex > 0) {
          inputText = inputText.slice(0, cursorIndex - 1) + inputText.slice(cursorIndex);
          cursorIndex--;
        }
      } else if (e.key === "Delete") {
        if (cursorIndex < inputText.length) {
          inputText = inputText.slice(0, cursorIndex) + inputText.slice(cursorIndex + 1);
        }
      } else if (e.key === "Enter") {
        if (inputText.trim()) {
          messages.push({from: "me", text: inputText.trim()});
          inputText = "";
          cursorIndex = 0;
        }
      } else if (e.key.length === 1) {
        inputText = inputText.slice(0, cursorIndex) + e.key + inputText.slice(cursorIndex);
        cursorIndex++;
      }
    });

    document.addEventListener("paste", (e) => {
      e.preventDefault();
      const paste = (e.clipboardData || window.clipboardData).getData("text");
      if (paste) {
        inputText = inputText.slice(0, cursorIndex) + paste + inputText.slice(cursorIndex);
        cursorIndex += paste.length;
      }
    });

    setInterval(() => {
      blinkState = !blinkState;
      draw();
    }, 500);

    draw();
  </script>
</body>
</html>
