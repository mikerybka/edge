<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>16 Lines 15px High Stripes</title>
  <style>
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid black;
      image-rendering: pixelated;
      background: white;
    }
  </style>
</head>

<body>
  <canvas id="stripedCanvas" width="320" height="240"></canvas>
  <script>
    const canvas = document.getElementById('stripedCanvas');
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = "top";
    let inputText = "";
    let cursorIndex = 0;
    let blinkState = true;
    let selectingState = false;
    let messages = [];
    let scrollOffset = 0;

    function calculateLines(maxWidth, inputText) {
      let lines = [""];
      inputText.split(" ").forEach((word, i) => {
        const lastLine = lines[lines.length - 1]
        const testLine = (lastLine + " " + word);
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && i > 0) {
          lines = [...lines, word];
        } else {
          lines[lines.length - 1] = testLine;
        }
      });
      return lines
    }


    // Draw rounded rectangle (for chat bubbles)
    function drawRoundedRect(x, y, w, h, r, fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.fill();
    }

    function calculateCursorCoordinates(inputLines, cursorIndex) {
      let cursorRow = 0;
      let cursorCol = 0;
      for (let i = 0; i < cursorIndex; i++) {
        if (inputLines[cursorRow].length > cursorCol) {
          cursorCol++;
        } else {
          cursorRow++;
          cursorCol = 0;
        }
      }
      return {cursorRow, cursorCol};
    }

    function draw() {
      const baseWidth = 320;
      const baseHeight = 240;
      const width = canvas.width;
      const height = canvas.height;
      const fontHeight = 14 * width / baseWidth;
      const margin = 4 * width / baseWidth;
      const padding = 4 * width / baseWidth;
      const titleFontHeight = padding + fontHeight + padding;
      const lineSpacing = (margin + padding + fontHeight + padding + margin) / 2;
      const maxInputTextWidth = width - margin - padding - padding - margin;
      const inputLines = calculateLines(maxInputTextWidth, inputText);
      const inputBoxColor = "#bbb";
      const inputBubbleColor = "white";
      const inputBoxWidth = width;
      const inputBoxHeight = lineSpacing * (inputLines.length + 1);
      const inputBoxX = 0;
      const inputBoxY = height - inputBoxHeight;
      const bubbleRadius = padding;
      const inputBubbleX = inputBoxX + margin;
      const inputBubbleY = inputBoxY + margin;
      const inputBubbleWidth = inputBoxWidth - margin - margin;
      const inputBubbleHeight = inputBoxHeight - margin - margin;
      const inputPadding = padding + margin;
      const {cursorRow, cursorCol} = calculateCursorCoordinates(inputLines, cursorIndex);
      const beforeCursor = inputLines[cursorRow].trimStart(' ').slice(0, cursorCol+1);
      ctx.font = `${fontHeight}px sans-serif`;
      const cursorX = inputPadding + ctx.measureText(beforeCursor).width;
      const cursorY = height - inputBoxHeight + margin + padding + cursorRow * lineSpacing;
      const maxMessageTextWidth = width - margin - margin - padding - padding - margin;

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Draw title bar

      // Draw chat

      // Draw input box
      ctx.fillStyle = inputBoxColor;
      ctx.fillRect(inputBoxX, inputBoxY, inputBoxWidth, inputBoxHeight);

      // Draw input bubble
      drawRoundedRect(inputBubbleX, inputBubbleY, inputBubbleWidth, inputBubbleHeight, bubbleRadius, inputBubbleColor);

      // Draw input lines
      ctx.fillStyle = 'black';
      for (let i = 0; i < inputLines.length; i++) {
        const x = inputBubbleX + padding;
        const y = inputBubbleY + padding + (i * lineSpacing);
        ctx.fillText(inputLines[i].trim(), x, y);
      }

      // Draw blinking cursor
      if (blinkState) {
          ctx.beginPath();
          ctx.moveTo(cursorX, cursorY);
          ctx.lineTo(cursorX, cursorY+fontHeight);
          ctx.strokeStyle = "#000";
          ctx.stroke();
      }
    }

    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey || e.metaKey) return;

      if (e.key === "ArrowLeft") {
        if (cursorIndex > 0) cursorIndex--;
      } else if (e.key === "ArrowRight") {
        if (cursorIndex < inputText.length) cursorIndex++;
      } else if (e.key === "Backspace") {
        if (cursorIndex > 0) {
          inputText = inputText.slice(0, cursorIndex - 1) + inputText.slice(cursorIndex);
          cursorIndex--;
        }
      } else if (e.key === "Delete") {
        if (cursorIndex < inputText.length) {
          inputText = inputText.slice(0, cursorIndex) + inputText.slice(cursorIndex + 1);
        }
      } else if (e.key === "Enter") {
        if (inputText.trim()) {
          messages.push({ from: "me", text: inputText.trim() });
          inputText = "";
          cursorIndex = 0;
        }
      } else if (e.key.length === 1) {
        inputText = inputText.slice(0, cursorIndex) + e.key + inputText.slice(cursorIndex);
        cursorIndex++;
      }
    });

    document.addEventListener("paste", (e) => {
      e.preventDefault();
      const paste = (e.clipboardData || window.clipboardData).getData("text");
      if (paste) {
        inputText = inputText.slice(0, cursorIndex) + paste + inputText.slice(cursorIndex);
        cursorIndex += paste.length;
      }
    });

    setInterval(() => {
      blinkState = !blinkState;
      draw();
    }, 500);

    draw();
  </script>
</body>

</html>