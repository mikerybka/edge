<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>16 Lines 15px High Stripes</title>
  <style>
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid black;
      image-rendering: pixelated;
      background: white;
    }
  </style>
</head>

<body>
  <canvas id="stripedCanvas" width="320" height="240"></canvas>
  <script>
    const canvas = document.getElementById('stripedCanvas');
    const ctx = canvas.getContext('2d');
    const stripeHeight = canvas.height / 16; // 15
    const fontSize = stripeHeight / 15 * 13;
    const maxWidth = 300;
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textBaseline = "top";
    let inputText = "";
    let cursorIndex = 0;
    let blinkState = true;
    let messages = [];
    let scrollOffset = 0;
    // let lines = [
    //     "",
    //     "",
    //     "Hey, how's it going?",
    //     "",
    //     "",
    //     "Not bad, yourself?",
    //     "",
    //     "",
    //     "I'm good, thanks.",
    //     "",
    //     "",
    //     "How's the wife and kids?",
    //     "",
    //     "",
    //     "They're great! Just got back from vacation",
    //     "in the Poconos.",
    //     "",
    // ];

    // function calculateLines(inputText, messages) {
    //     const lines = [];

    //     // Calculate input text area
    //     let workingLine = "";
    //     inputText.split(" ").forEach((word, i) => {
    //         const testLine = workingLine + " " + word + " ";
    //         const metrics = ctx.measureText(testLine);
    //         const testWidth = metrics.width;
    //         if (testWidth > maxWidth && i > 0) {
    //             lines.push({text: workingLine.trim(), align: "left"});
    //             workingLine = "";
    //         } else {
    //             workingLine = testLine;
    //         }
    //     });
    //     lines.push({text: workingLine.trim(), align: "left"});
    //     lines.push({text: "", align: "left"});
    //     lines.reverse();

    //     // Calculate messages
    //     Array.from(messages.slice(-5)).reverse().forEach(msg => {
    //         const align = msg.from === "me" ? "right" : "left";
    //         const msgLines = [];
    //         workingLine = ""
    //         msg.text.split(" ").forEach((word, i) => {
    //             const testLine = workingLine + " " + word + " ";
    //             const metrics = ctx.measureText(testLine);
    //             const testWidth = metrics.width;
    //             if (testWidth > maxWidth && i > 0) {
    //                 msgLines.push({text: workingLine.trim(), align});
    //                 workingLine = "";
    //             } else {
    //                 workingLine = testLine
    //             }
    //         });
    //         msgLines.reverse().forEach(line => {
    //             lines.push(line);
    //         })
    //         lines.push({text: "", align});
    //         lines.push({text: "", align});
    //     });

    //     if (lines.length < 17) {
    //         for (let i = lines.length; i < 17; i++) {
    //             lines.push({text: "", align: "left"})
    //         }
    //     }

    //     return lines.slice(0, 17).reverse()
    // }

    function calculateLines(maxWidth, inputText) {
      let lines = [""];
      inputText.split(" ").forEach((word, i) => {
        const lastLine = lines[lines.length - 1]
        const testLine = (lastLine + " " + word).trim();
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && i > 0) {
          lines = [...lines, word.trim()];
        } else {
          lines[lines.length - 1] = testLine;
        }
      });
      return lines
    }


    // Draw rounded rectangle (for chat bubbles)
    function drawRoundedRect(x, y, w, h, r, fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.fill();
    }

    function draw() {
      // Calculate coordinates
      const baseWidth = 320;
      const baseHeight = 240;
      const width = canvas.width;
      const height = canvas.height;
      const fontHeight = 14 * width / baseWidth;
      const margin = 4 * width / baseWidth;
      const padding = 4 * width / baseWidth;
      const lineSpacing = (margin + padding + fontHeight + padding + margin) / 2;
      const maxInputTextWidth = width - margin - padding - padding - margin;
      const inputLines = calculateLines(maxInputTextWidth, inputText);
      const inputBoxColor = "#bbb";
      const inputBubbleColor = "white";
      const inputBoxWidth = width;
      const inputBoxHeight = lineSpacing * (inputLines.length + 1);
      const inputBoxX = 0;
      const inputBoxY = height - inputBoxHeight;
      const bubbleRadius = padding;
      const inputBubbleX = inputBoxX + margin;
      const inputBubbleY = inputBoxY + margin;
      const inputBubbleWidth = inputBoxWidth - margin - margin;
      const inputBubbleHeight = inputBoxHeight - margin - margin;

      const maxMessageTextWidth = width - margin - margin - padding - padding - margin;


      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Draw input box
      ctx.fillStyle = inputBoxColor;
      ctx.fillRect(inputBoxX, inputBoxY, inputBoxWidth, inputBoxHeight);

      // Draw input bubble
      drawRoundedRect(inputBubbleX, inputBubbleY, inputBubbleWidth, inputBubbleHeight, bubbleRadius, inputBubbleColor);

      // Draw input lines
      for (let i = 0; i < inputLines.length; i++) {
        const x = inputBubbleX + padding;
        const y = inputBubbleY + padding + (i * lineSpacing);
        console.log({y, inputBubbleY})
        ctx.fillStyle = 'black';
        ctx.fillText(inputLines[i], x, y);
      }
      // drawInputLines();

      // const lines = calculateLines(inputText, messages);
      // lines.forEach((line, i) => {
      //     const textY = i * stripeHeight;
      //     if (line.align === "right") {
      //         ctx.textAlign = "right";
      //         ctx.fillText(line.text, width-8, textY);
      //     } else {
      //         ctx.textAlign = "left";
      //         ctx.fillText(line.text, 8, textY);
      //     }
      // })

      // Draw messages
      // drawMessages();

      // Draw blinking cursor
      // if (blinkState) {
      //     const inputPadding = 8;

      //     const beforeCursor = inputText.slice(0, cursorIndex);
      //     const cursorX = inputPadding + ctx.measureText(beforeCursor).width;
      //     ctx.beginPath();
      //     ctx.moveTo(cursorX, canvas.height - inputBoxHeight + 6);
      //     ctx.lineTo(cursorX, canvas.height - inputPadding - 6);
      //     ctx.strokeStyle = "#000";
      //     ctx.stroke();
      // }
    }

    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey || e.metaKey) return;

      if (e.key === "ArrowLeft") {
        if (cursorIndex > 0) cursorIndex--;
      } else if (e.key === "ArrowRight") {
        if (cursorIndex < inputText.length) cursorIndex++;
      } else if (e.key === "Backspace") {
        if (cursorIndex > 0) {
          inputText = inputText.slice(0, cursorIndex - 1) + inputText.slice(cursorIndex);
          cursorIndex--;
        }
      } else if (e.key === "Delete") {
        if (cursorIndex < inputText.length) {
          inputText = inputText.slice(0, cursorIndex) + inputText.slice(cursorIndex + 1);
        }
      } else if (e.key === "Enter") {
        if (inputText.trim()) {
          messages.push({ from: "me", text: inputText.trim() });
          inputText = "";
          cursorIndex = 0;
        }
      } else if (e.key.length === 1) {
        inputText = inputText.slice(0, cursorIndex) + e.key + inputText.slice(cursorIndex);
        cursorIndex++;
      }
    });

    document.addEventListener("paste", (e) => {
      e.preventDefault();
      const paste = (e.clipboardData || window.clipboardData).getData("text");
      if (paste) {
        inputText = inputText.slice(0, cursorIndex) + paste + inputText.slice(cursorIndex);
        cursorIndex += paste.length;
      }
    });

    setInterval(() => {
      blinkState = !blinkState;
      draw();
    }, 500);

    draw();
  </script>
</body>

</html>